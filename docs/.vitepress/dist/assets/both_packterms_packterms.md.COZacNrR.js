import{_ as e,c as r,o as a,ae as o}from"./chunks/framework.BC5PaHTK.js";const c=JSON.parse('{"title":"마인크래프트 팩, 모드 프로그램 용어 정리","description":"","frontmatter":{"outline":[2,3]},"headers":[],"relativePath":"both/packterms/packterms.md","filePath":"both/packterms/packterms.md","lastUpdated":1761409023000}'),n={name:"both/packterms/packterms.md"};function s(l,t,d,i,f,p){return a(),r("div",null,t[0]||(t[0]=[o('<h1 id="마인크래프트-팩-모드-프로그램-용어-정리" tabindex="-1">마인크래프트 팩, 모드 프로그램 용어 정리 <a class="header-anchor" href="#마인크래프트-팩-모드-프로그램-용어-정리" aria-label="Permalink to &quot;마인크래프트 팩, 모드 프로그램 용어 정리&quot;">​</a></h1><p>초보자들이 보기엔 햇갈릴 수 있는 마인크래프트에서 많이 씌이는 팩, 포맷, 프로그램등을 지칭하는 용어를 전체적으로 정리한 문서</p><div class="tip custom-block"><p class="custom-block-title">참고</p><p>설명에서는 모드/서버 플러그인/데이터팩등등을 전부 다른것처럼 설명하지만<br> 실제론 기능을 서로 사용하는 상위/하위 개념 또는 둘 다에서 사용될 수 있는 부분이 존재한다.<br> 다만, 일반 이용자들이 자세히 알 필요는 없기 때문에 이에 대해서 자세히 설명하진 않는다.</p></div><br><hr><br><h1 id="공식-팩" tabindex="-1">공식 팩 <a class="header-anchor" href="#공식-팩" aria-label="Permalink to &quot;공식 팩&quot;">​</a></h1><h2 id="리소스팩" tabindex="-1">리소스팩 <a class="header-anchor" href="#리소스팩" aria-label="Permalink to &quot;리소스팩&quot;">​</a></h2><p>자바 / 베드락에디션에서 공식으로 <strong>지원하는 텍스쳐등 리소스를 바꿀 수 있는 팩이다.</strong><br> 이전에는 텍스쳐팩으로 불리었으나, 현제는 셰이더, 모델링등 여러가지를 바꿀 수 있게 되며 리소스팩으로 이름이 바뀌었다.<br> 현제도 텍스쳐팩과 리소스팩을 용어를 혼용해서 사용하고 있는 경우가 있으며, 혼용해서 사용해도 상관 없다.</p><p>리소스팩은 클라이언트측에서만 적용되며, 시각적인 부분에서만 수정이 가능하다.<br> 즉, UI(인터페이스)를 바꾸는것을 제외한다면 판정 범위같이 게임 플레이 자체에 직접적인 영향을 줄 수는 없다.</p><p>공식적으로 리소스팩으로 가능한 부분은 다음과 같다.<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><table tabindex="0"><thead><tr><th>지원 항목</th><th style="text-align:center;">자바</th><th style="text-align:center;">베드락</th></tr></thead><tbody><tr><td>블록 텍스쳐 번경</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td></tr><tr><td>엔티티 텍스쳐 번경</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td></tr><tr><td>블록 모델링 번경</td><td style="text-align:center;">O</td><td style="text-align:center;">X <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></td></tr><tr><td>아이템 모델링 번경</td><td style="text-align:center;">블록 모델과 동일</td><td style="text-align:center;">엔티티 모델과 동일</td></tr><tr><td>엔티티 모델링 번경</td><td style="text-align:center;">X</td><td style="text-align:center;">O</td></tr><tr><td>엔티티 에니메이션 번경/추가</td><td style="text-align:center;">X</td><td style="text-align:center;">O</td></tr><tr><td>파티클 텍스쳐 번경</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td></tr><tr><td>파티클 추가/번경</td><td style="text-align:center;">X</td><td style="text-align:center;">O</td></tr><tr><td>UI 텍스쳐 번경</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td></tr><tr><td>UI 번경</td><td style="text-align:center;">O<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></td><td style="text-align:center;">O</td></tr><tr><td>텍스쳐 랜덤화</td><td style="text-align:center;">O</td><td style="text-align:center;">일부만 가능</td></tr><tr><td>셰이더 수정</td><td style="text-align:center;">O</td><td style="text-align:center;">X<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></td></tr><tr><td>블록 에니메이션 추가</td><td style="text-align:center;">O<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></td><td style="text-align:center;">X</td></tr><tr><td>블록 그림자 제거</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td></tr><tr><td>텍스쳐 에니메이션 추가</td><td style="text-align:center;">블록/아이템/엔티티</td><td style="text-align:center;">O</td></tr></tbody></table><p>자바와 베드락 둘 다 맵 또는 서버에 추가해 같이 배포, 호스팅할 수 있다.</p><h2 id="데이터팩" tabindex="-1">데이터팩 <a class="header-anchor" href="#데이터팩" aria-label="Permalink to &quot;데이터팩&quot;">​</a></h2><p>자바에서 공식으로 지원하는 <strong>게임의 일부 규칙을 바꿀 수 있는 팩이다.</strong><br> 맵에 적용하는 식으로 적용이 가능하며, 커맨드를 커맨드 블록이 아닌 스크립트 파일로 에디팅하거나, 다이얼로그나 맵 생성 방식 번경과 같이 데이터팩에서만 사용 가능한 기능을 사용할때 씌인다.<br> 커맨드를 사용하는 개념과 비슷하기 때문에 실제로 바꿀 수 있는 부분은 커맨드로 가능하거나 바이옴 관련 부분 뿐, 새 블록, 아이템, 몹등등을 추가하진 못한다.<br> 때문에 주로 맵을 제작하거나 모드 없이 기능이 필요한 경우에 사용된다.</p><h2 id="애드온" tabindex="-1">애드온 <a class="header-anchor" href="#애드온" aria-label="Permalink to &quot;애드온&quot;">​</a></h2><p>베드락에서 공식으로 지원하는 <strong>게임의 규칙을 수정하고, 컨텐츠를 만들 수 있는 팩이다.</strong><br> 맵에 적용하는 식으로 적용이 가능하며, 베드락에서 공식적으로 지원하는 API를 사용할 수 있다.<br> 자바의 데이터팩과 다른점이라면, 베드락은 모드가 불가능<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>하기 때문에 애드온에서 대부분이 구현이 가능하게 되어있다.</p><p>때문에 모드와 혼동돼는 경우도 있지만, 모드는 일종의 해킹으로 코딩만 가능하다면 구현 범위가 무한인 반면, 베드락 애드온 API는 모장이 지원하는 범위 내에서만 가능하다는 단점이 있다.<br> 따라서 애드온은 모드보다 구현이 가능한 범위가 훨씬 제한적이다.<br> 대신 공식적으로 지원하는 기능이기 때문에 모드같이 따로 설치를 요구하지 않아 사용자 입장에서 덜 부담스럽다는 장점이 있다.</p><p>공식으로 지원하는 기능이기 때문에 베드락 인게임 공식 마켓플레이스에서 판매되는 애드온을 구매해 사용할 수 있다.<br> 다만, 애드온도 버전이 지남에 따라 고장나는 경우가 있기 때문에 오래전에 지원이 멈춘 애드온/맵들은 구매를 주의하고 가능한 잘 알려진 제작팀에서 제작된것을 사용하는것이 좋다.</p><p>접근이 쉬운 모바일/게임 콘솔이 주 대상인 만큼 어린 연령층이나 컴퓨터에 익숙하지 않은 이용자층이 많아 사기<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>가 많다. 때문에 검증된 사이트에서 찾는것을 추천한다.<br><a href="https://www.curseforge.com/minecraft-bedrock" target="_blank" rel="noreferrer">Curseforge</a>와 <a href="https://mcpedl.com" target="_blank" rel="noreferrer">MCPEDL</a>이 대표적이나 Curseforge가 MCPEDL을 인수한 이후 연동 작업을 진행중이기 때문에 둘 중 뭘써도 상관은 없다.</p><p>베드락 관련 개발자들이 모여있는 중심 커뮤니티인 <a href="https://wiki.bedrock.dev/discord" target="_blank" rel="noreferrer">Bedrock Add-Ons</a>디스코드에서 찾는것도 하나의 방법이다.</p><h2 id="스킨팩" tabindex="-1">스킨팩 <a class="header-anchor" href="#스킨팩" aria-label="Permalink to &quot;스킨팩&quot;">​</a></h2><p><strong>베드락에서 스킨 여러개를 묶어서 배포할 수 있는 팩이다.</strong></p><br><br><hr><br><h1 id="서버" tabindex="-1">서버 <a class="header-anchor" href="#서버" aria-label="Permalink to &quot;서버&quot;">​</a></h1><h2 id="서버-플러그인" tabindex="-1">서버 플러그인 <a class="header-anchor" href="#서버-플러그인" aria-label="Permalink to &quot;서버 플러그인&quot;">​</a></h2><p><strong>서버에서 클라이언트와 주고받는 패킷 관련을 수정, 제작하거나 게임의 규칙을 바꾸고 수정할 수 있는 요소이다.</strong><br> 공식은 아니기 때문에 Paper와 같은 서버 구동기가 필요하며 모드와 달리 바닐라의 기능을 크게 벗어날 수 없다.<br> 대신 마인크래프트의 기능을 최대한 활용하여 기능을 구현한다.<br> 공식적으로 엔티티를 추가할 수는 없지만 디스플레이 엔티티를 이용하여 모델엔진와 미스틱몹 플러그인으로 커스텀 몹을 만드는걸 생각하면 이해하기 쉽다.</p><p>모드와 관련된 패킷도 당연히 주고받을 수 있으며 당연히 전체적으로 데이터팩보다 구현할 수 있는 범위가 넓다.</p><p>베드락에서는 주로 자바를 사용하는 자바 플러그인과는 다르게 주로 C++과 파이썬으로 제작된다.</p><h2 id="서버-구동기" tabindex="-1">서버 구동기 <a class="header-anchor" href="#서버-구동기" aria-label="Permalink to &quot;서버 구동기&quot;">​</a></h2><p><strong>마인크래프트 서버를 구동할 수 있는 구동기다.</strong><br> 바닐라 서버외의 따로 제작된 구동기를 사용해 설명했듯이 전용 API로 플러그인등을 제작해 사용할 수 있다.<br> Paper나 Bukkit이 잘 알려진 대표적인 예 이다.<br> 베드락에는 대표적으로 Endstone이 있다.</p><p>모드 로더인 Fabric, Neoforge 등도 대표적인 서버 구동기다.<br> 이 경우 서버측 모드를 활용해 플러그인처럼 사용이 가능하다.<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup></p><br><br><hr><br><h1 id="모드" tabindex="-1">모드 <a class="header-anchor" href="#모드" aria-label="Permalink to &quot;모드&quot;">​</a></h1><h2 id="모드-1" tabindex="-1">모드 <a class="header-anchor" href="#모드-1" aria-label="Permalink to &quot;모드&quot;">​</a></h2><p><strong>게임을 수정해 컨텐츠를 제작, 수정할 수 있는 요소다.</strong><br> 기존 게임의 제한을 완전히 뚫어버릴 수 있기 때문에 제작이 매우 자유롭다.</p><p>일반적으로 모드라 하면 자바의 모드를 가리키며 베드락에서는 보안상의 이유로 공식에서 모드를 금지한다.<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup></p><h2 id="모드-로더" tabindex="-1">모드 로더 <a class="header-anchor" href="#모드-로더" aria-label="Permalink to &quot;모드 로더&quot;">​</a></h2><p><strong>모드를 실행할 수 있게 해주는 서드파티 프로그램이다.</strong> 대표적으로 Forge, Fabric, Neoforge가 있으며 현제 주류로 사용 되는것은 Fabric이다.</p><p>Fabric의 포크, 극 초창기의 모드 로더, 클래식/베타/알파 버전용 모드 로더까지 합치면 13개정도가 있다.</p><p>원래는 Forge가 가장 강력한 메인이었으나 Forge의 느린 업데이트 속도, 복잡한 API등 때문에 Fabric이 나오고 현제 주류가 되었다.<br> 거기다 Forge의 내부 논란까지 터지며 내부 개발진 대부분이 Neoforge로 옮기며 현제는 오래된 버전이 아니라면 권장하지 않는 모드 로더가 되었다.</p><h2 id="셰이더팩" tabindex="-1">셰이더팩 <a class="header-anchor" href="#셰이더팩" aria-label="Permalink to &quot;셰이더팩&quot;">​</a></h2><p><strong>셰이더 모드로 작동하는 셰이더를 수정하고 추가하는 팩이다.</strong></p><p>리소스팩으로도 코어 셰이더를 수정할 수 있지만 통상적으로 셰이더팩은 셰이더 모드를 사용한 팩을 의미한다.</p><p>흔히들 셰이더팩 = 그래픽을 이쁘게 해주는 역할이라고 생각하지만, 정확히는 셰이더팩은 셰이더 코드를 수정하고 추가하는 팩이다.<br> 셰이더 코드란 아주 쉽게 말해서 화면에 시각적으로 표시해주는 그래픽등을 코딩으로 연산 및 구현하는 역할이다.</p><p>1.7 셰이더 모드가 나온 이후 옵티파인에 기능이 통합 되었으며 이후 옵티파인의 느린 업데이트, 매우 안좋은 모드 호환성, 폐쇠적인 코드 때문에 이후 옵티파인 파이프라인을 지원하는 아이리스 셰이더가 나왔으며 현제는 아이리스 셰이더가 업계 주류로 사용되고 있다.<br> 다만 폿지 - 네오폿지 관계와는 다르게 업계에서 내에서 부정적인 느낌은 아니다.<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup></p><p>아이리스 셰이더 자체도 옵티파인 파이프라인을 사용하기 때문에 웬만하면 옵티파인 - 아이리스 셰이더 양쪽에서 호환이 되나 아이리스 셰이더에서만 지원하는 API가 있기 때문에 웬만하면 Iris Shader을 사용하는것이 좋다.</p><p>아이리스 셰이더의 폿지 포크인 Oculus및 마인크래프트 1.7.10 버전용 포크인 Angelica도 있다.</p><p>설치시 주의사항등 자세한건 <a href="/doc-blog/java/shader_rec/shader_rec.html">셰이더팩 추천 목록</a>를 사용하는걸 추천한다.</p><h2 id="모드팩" tabindex="-1">모드팩 <a class="header-anchor" href="#모드팩" aria-label="Permalink to &quot;모드팩&quot;">​</a></h2><p><strong>모드, 세팅, 각종 팩등등의 인스턴트를 통째로 배포하는 종합 팩이다.</strong></p><p>원하는 모드들을 찾아다니고 호환되는지 확인하고 할 필요 없이 50개가 넘어가는 모드들을 손쉽게 설치할 수 있다는 장점이 있다.</p><p>예전에는 말 그대로 모드와 팩들을 전부 집어넣어 저작권 문제가 있었지만 현제는 가능한 대부분 팩들을 Modrtith 또는 Curseforge의 API에서 직접 다운로드 하는 방식으로 바뀌어 메이져한 콘텐츠가 되었다.<br> 옵티파인같이 여러 기능을 한번에 합한 클라이언트 모드만 합친 모드팩부터 각종 RPG모드를 합쳐 넓고 광범위한 아이템, 몹, 바이옴에 스토리까지 존재하는 모드팩 등등 다양한 모드팩이 존재한다.</p><p>크게 주류 포맷으로 Modrinth 모드팩, Curseforge 모드팩이 있으며, 이름에서도 알 수 있듯이<br> Modrinth 모드팩은 Modrinth API를 사용하는 모드팩으로 Modrinth에서만 업로드가 가능하며 Modrinth 앱에서는 Modrinth 모드팩만 불러올 수 있고 Curseforge 모드팩은 Curseforge API를 사용하는 모드팩으로 Curseforge에서만 업로드가 가능하며 Curseforge 앱에서는 Curseforge 모드팩만 불러올 수 있다.</p><p>둘 다 관리하고 싶다면 Prizm 런처등을 사용하면 된다.</p><h2 id="클라이언트-클라이언트-모드" tabindex="-1">클라이언트 (클라이언트 모드) <a class="header-anchor" href="#클라이언트-클라이언트-모드" aria-label="Permalink to &quot;클라이언트 (클라이언트 모드)&quot;">​</a></h2><p><strong>버전 및 모드 관리 프로그램, PVP등에 필요한 클라이언트측 모드, 전용 서버 및 캐릭터 커스텀 요소등등의 서비스를 종합적으로 제공하는 프로그램이다.</strong></p><p>대표적으로 페더 클라이언트, 루나 클라이언트등등이 있으며 위에서 말했듯이<br> 모드, 버전 관리등의 런처 프로그램<br> 나침반, 체력 관리, 갑옷 내구도 표시 등등의 클라이언트측 모드<br> 커스텀 망토, HD 스킨, 이름표 꾸미기등 커스텀 전용 요소 판매와 전용 서버등등의 서비스를<br> 종합적으로 제공하는 프로그램을 의미한다.</p><p>여러 모드 기능이 종합적으로 들어있기 때문에 다른 모드와 호환성이 안좋으며, 대신 PVP, 야생, 하이픽셀 서버등에 유용한 굉장히 많은 기능이 한번에 들어있기 때문에 해당 기능들을 번거롭게 찾아다니고 설치할 필요 없이 프로그램 설치 하나만으로 사용할 수 있다는 장점이 있다.</p><p>대신 페더클등에서 보안적으로 문제가 있을 수 있으니 주의할 필요 또한 있다.</p><br><br><hr><br><h1 id="써드파티-프로그램" tabindex="-1">써드파티 프로그램 <a class="header-anchor" href="#써드파티-프로그램" aria-label="Permalink to &quot;써드파티 프로그램&quot;">​</a></h1><h2 id="커스텀-런처" tabindex="-1">커스텀 런처 <a class="header-anchor" href="#커스텀-런처" aria-label="Permalink to &quot;커스텀 런처&quot;">​</a></h2><p><strong>기존 공식 런처 대신 마인크래프트를 실행할 수 있게 만든 커스텀 런처이다.</strong></p><p>주로 버전 관리및 모드 관리를 편하게 해주는 기능이 존재한다.<br> 특히나 공식 런처가 완전히 새로 제작되며 마인크래프트 설치가 불가능한 버그, 매우 느린 시작 속도등 때문에 커스텀 런처를 사용하는 경우도 늘어났다.</p><p>주로 Prism, MultiMC등이 존재하며 Modrinth와 Curseforge에서 지원하는 공식 앱도 존재한다.<br> 특히나 Modrinth와 Curseforge앱은 기업에서 개발 및 유지하기 때문에 일반 사용자 입장에서 사용이 매우 편리하다는 장점이 있다.</p><h3 id="인스턴트" tabindex="-1">인스턴트 <a class="header-anchor" href="#인스턴트" aria-label="Permalink to &quot;인스턴트&quot;">​</a></h3><p><strong>일반적으로 커스텀 런처에서 버전을 관리하기 위해 사용되는 개념이다.</strong></p><p>쉽게 설명해 마인크래프트를 여러개를 설치한다고 생각하면 편하다.<br> 각 인스턴트마다 마인크래프트 폴더가 분리되기 때문에 모드, 설정, 버전등등등을 따로 관리할 수 있다. 또한 모드팩을 통해 배포또한 가능하다.</p><h3 id="modritnh-app" tabindex="-1">Modritnh APP <a class="header-anchor" href="#modritnh-app" aria-label="Permalink to &quot;Modritnh APP&quot;">​</a></h3><p>모드린스에서 공식적으로 개발하는 커스텀 런처이다.<br> 앱 내에서 바로 Modinth의 컨텐츠를 설치하고 불러올 수 있기 때문에 편리하며<br> 커스텀 런처중에서 가장 쓰기 편한 편이기도 하다.</p><h3 id="curseforge-app" tabindex="-1">Curseforge APP <a class="header-anchor" href="#curseforge-app" aria-label="Permalink to &quot;Curseforge APP&quot;">​</a></h3><p>커스폿지에서 공식적으로 개발하는 커스텀 런처이다.<br> 앱 내에서 바로 Curseforge의 컨텐츠를 설치하고 불러올 수 있기 때문에 편리하다.</p><p>커스폿지 자체가 마인크래프트 뿐만 아니라 다양한 게임을 지원하는 모드 플랫폼이기 때문에 스타듀벨리, 인조이등의 다른 게임의 모드를 같이 관리할 수 있다는 장점 또한 존재한다.</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>자바의 경우 코어 셰이더를 활용하면 인터렉션을 제외한 대부분을 구현할 수 있지만 여기서는 경우에서 대부분 제외한다. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>일부 특수한 방법으로 일부 블록에 한해서만 가능하지만, 공식으로 권장하는 방법은 아니다. <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>1.17부터 코어 셰이더로 번경 가능. 단, 위치와 모양을 바꿀 뿐 베드락처럼 버튼등 기능적으로 번경하거나 추가하는건 불가능. <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>기존에는 가능했으나 렌더드래곤이라는 새 렌더엔진 도입 이후 공식적으로 막혔다. <a href="https://minecraft.wiki/w/RenderDragon" target="_blank" rel="noreferrer">위키</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>모델 여러개를 사용한 스톱모션같은 방식이다. <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p>모드들은 전부 보안상의 이유로 막혔으며, 현제 모드들은 규칙을 직접적으로 수정하지 않는 클라이언트 모드거나 서버에서 사용되는 API를 사용하는 방식이다. <a href="#fnref6" class="footnote-backref">↩︎</a></p></li><li id="fn7" class="footnote-item"><p>복돌이거나 없는 콘텐츠를 있는듯이 홍보하는 경우가 많다. 이러한 경우 사이트 접속 및 다운로드 과정에서 보안상 위험에 노출될 수 있으니 주의해야한다. <a href="#fnref7" class="footnote-backref">↩︎</a></p></li><li id="fn8" class="footnote-item"><p>모드가 플러그인처럼 작동한다기 보단 이렇게 작동하게 만들어진 모드 = 플러그인이라고 이해하면 편하다. <a href="#fnref8" class="footnote-backref">↩︎</a></p></li><li id="fn9" class="footnote-item"><p>사실 공식에서 금지한다고 한 적은 없고, 다만 크로스 플랫폼을 위해 공식 서버를 기본적으로 지원하고 마켓플레이스가 있기 때문에 보안에 민감한 만큼 모드가 나올때마다 매번 보안을 이유로 막힌다.<br> 현제 스크립트로 한번, PDB로 두번 막혔으며 다만 PDB는 많은 서버에서 사용하던 만큼 관련 회의를 통해 서버 API로 어느정도 대체가 가능하게 했다.<br> 예전 자료를 찾다보면 스크립트라고 돼있는 자료가 이 &quot;모드&quot;의 흔적이다. 물론 스크립트는 핵처럼 쓸 수 있던지라 막혀도 막힐만 했다는 반응이었다.<br> 현제도 모드가 있으나 예전처럼 직접 게임의 규칙을 건드리는 류는 매우 적고 모드 시장 자체도 비주류기 때문에 문서에서 크게 설명하진 않는다. <a href="#fnref9" class="footnote-backref">↩︎</a></p></li><li id="fn10" class="footnote-item"><p>모드 자체의 노후화및 유지보수 난이도 문제가 있기도 하고 사실상 1인 개발이고 셰이더 업계를 이제까지 이끌어 줬다는 부분 덕분에 존중한다는 느낌이 강하다. <a href="/doc-blog/java/shader_rec/shader_rec.html#optifine-update">자세한 내용은 이 글 참고</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p></li></ol></section>',85)]))}const b=e(n,[["render",s]]);export{c as __pageData,b as default};
